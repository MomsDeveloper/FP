# Lab1

## Титульный лист

- Студент: `Хабнер Георгий Евгеньевич`
- Группа: `P3331`
- ИСУ: `368982`

---

## Описание проблемы

---

### Проблема 14

The following iterative sequence is defined for the set of positive integers:

n → n/2 (n is even)
n → 3n + 1 (n is odd)

Using the rule above and starting with 13, we generate the following sequence:

13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1

It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

Which starting number, under one million, produces the longest chain?
NOTE: Once the chain starts the terms are allowed to go above one million.

---

### Проблема 17

If the numbers 1 to 15 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?

NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of "and" when writing out numbers is in compliance with British usage.

---

## Ключевые моменты реализации

---

### Проблема 14

1. [Хвостовая рекурсия](src/CollatzTail.elm)

Подсчет наибольшей длины последовательности в `longestCollatzTail`:
- `collatzLength` - вычисление длины последовательности для числа `n`
(здесь используется хвостовая рекурсия)
- сравнение длины последовательности для числа `n` с максимальной длиной
- запись в аккумулятор максимальной длины последовательности и числа, для которого она была найдена
- переход к следующему числу

2. [Рекурсия](src/CollatzRec.elm)

Подсчет наибольшей длины последовательности в `longestCollatzRec`:
- `collatzLengthRec` - вычисление длины последовательности для числа `n`
- сравнение длины последовательности для числа `n` с максимальной длиной
- запись в аккумулятор максимальной длины последовательности и числа, для которого она была найдена
- переход к следующему числу

3. [Модульная реализация](src/CollatzModule.elm)

Подсчет наибольшей длины последовательности в `longestCollatzModule`:

- `collatzSeqsStartAndLength` - рекурсивное формирование списка пар (число, длина последовательности)
- `maxCollatzSeq` - поиск максимальной длины последовательности в списке пар


4. [Map](src/CollatzMap.elm)

Подсчет наибольшей длины последовательности в `longestCollatzMap`:

- создание списка пар (число, последовательность) с использованием `collatzSeq` для каждого числа
- перевод списка пар в список пар (число, длина последовательности)
- поиск максимальной длины последовательности в списке пар

---

### Проблема 17

1. [Рекурсия](src/NumberLetterRec.elm)

Во всех методах для перевода числа в строку используется одинаковая функция `numberToWords`:

- Если n == 0: возвращается пустая строка.
- Если n < 10: используется массив ones для получения соответствующей строки.
- Если n < 20: используется массив teens.
- Если n < 100: десятки выбираются из массива tens, а единицы добавляются рекурсивным вызовом.
- Если n < 1000: используется массив ones для сотен. Если есть остаток (не ноль), добавляется слово "hundredand", за которым следует рекурсивное преобразование остатка.
- Если n == 1000: возвращается "onethousand".

Подсчет количества букв в числе в `numberLetterRec`:

- `numberToWords` - перевод числа в слова
- рекурсивный подсчет суммы длин слов для чисел от 1 до `n`

2. [Хвостовая рекурсия](src/NumberLetterTail.elm)

Подсчет количества букв в числе в `numberLetterTail`:

- `numberToWords` - перевод числа в слова
- хвостовая рекурсия для подсчета суммы длин слов для чисел от 1 до `n` с использованием аккумулятора для сохранение текущей суммы

3. [Модульная реализация](src/NumberLetterModule.elm)

Подсчет количества букв в числе в `numberLetterModule`:

- `numberSeq` - формирование списка чисел от 1 до `n` в виде их длин в словарном представлении
(изначально число переводится в слово, затем считается длина слова)
- суммирование длин слов в списке посредством `List.foldl`

4. [Map](src/NumberLetterMap.elm)

Подсчет количества букв в числе в `numberLetterMap`:

- создание списка чисел от 1 до `n` в их словарном представлении
- перевод списка чисел в список длин слов
- суммирование длин слов в списке

---

### Выводы

По сравнению с обычной рекурсией, которая более интуитивна, хвостовая рекурсия позволяет избежать переполнения стека за счет того, что рекурсивный вызов является последней операцией (позволяет оптимизировать вызов в цикл). Это делает её более эффективной при работе с большими объемами данных. 

Использование Map сокращает код и позволяет более элегантно и компактно итерироваться по спискам, в отличие от обычной рекурсии. Это делает решения проще и более выразительными.

Elm произвел впечатление языка, ориентированного на написание чистого, легко читаемого кода, особенно в задачах, связанных с обработкой списков. Сильная система типов значительно снижает вероятность ошибок, связанных с некорректными типами данных, и упрощает отладку.

